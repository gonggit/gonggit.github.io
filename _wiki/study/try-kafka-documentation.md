---
layout  : wiki
title   : 카프카 공식 문서 읽어보기 (1) 
summary :  
date    : 2024-04-19 17:01:29 +0900
updated : 2024-05-14 18:21:59 +0900
tag     : kafka 
resource: D5/EBC879-A374-41EF-A167-502044C2A8A9
toc     : true
public  : true
parent  : [[/kafka]] 
latex   : false
---
* TOC
{:toc}

# 카프카를 만나다
카프카 공식문서를 보고 정리한다. (추후 업데이트)


# 이벤트 스트리밍(Event Streaming)
근본적으로 카프카는 **이벤트 스트림을 처리하기 위한 프레임워크**라고 할 수 있다. 이벤트 스트리밍이란 인간의 몸에 있는 신경계의 디지털 버전이다. 그러니까 신경계가 몸 내/외부에서 끊임없이 쏟아지는 무수한 자극 정보를 처리하는 시스템인것 처럼, 무수한 소스(데이터베이스, 센서, 모바일 기기, 클라우드 서비스 그리고 소프트웨어 제품)에서 끊임없이 발생하는 **이벤트**를 처리하는 시스템인 것이다.

조금 더 기술적인 측면에서 보자면, 이벤트 스트리밍이란 

1. 실시간으로 이벤트 수신(capturing)
2. 복구를 위해 이벤트 저장(storing)
3. 이벤트를 실시간 혹은 배치로 조작, 처리 및 대응(manipulating, processing, reacting)
4. 다른 이벤트 스트림으로 라우팅(routing)

하는 기술이다.

# 카프카 = 이벤트 스트리밍 플랫폼

카프카는 유즈 케이스에 맞는 시스템을 구축하기 위해 세 개의 핵심적인 기능을 제공한다.

1. 이벤트 스트림을 발행(produce) 하거나 구독(subscribe) 할 수 있다.
2. 이벤트 스트림을 원하는 만큼 견고하고 신뢰성 있게 저장할 수 있다.
3. 이벤트 스트림을 실시간 혹은 배치로 처리할 수 있다.

이런 기능은 분산 처리, 고가용성, 유연함, 장애 허용(fault-tolerant) 그리고 안전함을 보장하는 방식으로 제공된다. 카프카는 베어메탈, 가상 머신, 컨테이너, 온프레미스, 클라우드 등에 배포할 수 있으며, 직접 운영하거나 매니지드 서비스를 사용할 수도 있다.

# 카프카는 어떻게 동작하나요?
카프카는 분산 시스템으로 서버와 클라이언트가 고성능의 TCP 네트워크 프로토콜을 이용해 통신하는 구조이다. 

### 서버
카프카는 **여러 지역의 데이터 센터** 혹은 **클라우드 서비스의 다양한 리전**에 분포되어있는 서버들로 구성된 클러스터로 동작한다. 이런 서버들 중 스토리지 레이어를 구성하는 서버들을 **브로커**라고 부르고, Kafka Connect 처럼 데이터베이스 혹은 다른 카프카 클러스터 등 외부 시스템으로부터 지속적으로 이벤트 스트림을 불러오고 내보내는 기능을 하는 서버들이 있다.

### 클라이언트

네트워크 문제나 시스템 오류가 발생한 경우에도 이벤트 스트림을 병렬로 읽고 쓰고 처리하는 대규모의 내결함성을 갖춘 분산 어플리케이션 혹은 마이크로서비스를 작성할 수 있다. 이미 카프카 커뮤니티에서는 여러가지 언어로 고수준에서 사용할 수 있는 클라이언트를 제공하고 있다.

# 메인 컨셉과 용어

### Event
이벤트란 현실세계 혹은 비즈니스 세계에서 **"어떤 일이 일어났다"**는 사실이며, 문서에 따라 레코드(record) 혹은 메세지(message)로 불리기도 한다. 카프카에 데이터를 쓰거나 읽을 때 이벤트의 형태를 이용한다. 개념적으로 이벤트는 Key-Value 로 이루어져있고, 부가적인 메타데이터 헤더가 있다. 이벤트의 예시는 아래와 같다.

```
Event key: "철수"
Event value: "영희에게 20만원을 지불했다."
Event timestamp: "2024년 4월 18일 오후 9시 30분"
```

### Producer, Consumer
Producer는 카프카에 이벤트를 발행(쓰는) 클라이언트 어플리케이션이고, Consumer는 카프카로부터 이벤트를 수신(읽는) 클라이언트 어플리케이션이다. 카프카의 핵심 개념인 고확장성(high scalability)을 달성하기 위해 producer와 consumer는 완전히 분리되어있고(fully decoupled) 서로의 존재를 알지 못한다. 예를 들어 producer는 consumer가 이벤트를 읽는 것을 기다릴 필요가 없다. 카프카는 exactly once와 같은 여러 수준의 보장을 제공한다.

### Topic

카프카는 이벤트를 **토픽** 단위로 견고하게 저장한다. 매우 단순히 보자면 토픽은 파일시스템의 폴더와 같고, 이벤트들은 이 폴더에 저장되는 것과 같다. 

토픽은 항상 **멀티 프로듀서, 멀티 컨슈머** 형태다. 말인 즉슨, 어떤 토픽에 0개 이상의 프로듀서들을 연결하거나 마찬가지로 0개 이상의 컨슈머를 연결할 수 있다. 토픽에 저장된 메세지는 전통적인 메세징 시스템과 달리 **원할 때마다 읽을 수 있고 소비 후에도 지워지지 않는다.** 대신 카프카가 이벤트를 얼마나 오래 보관하고 있을지 토픽별로 설정할 수 있고, 그 기간 후에 이벤트가 버려진다. 카프카의 성능은 **데이터 용량과 관계 없이 일정**하기 때문에 긴 시간동안 데이터를 저장하더라도 전혀 문제가 없다. 

토픽은 **파티션**되어 있다(partitioned). 말인 즉슨 토픽은 이벤트를 여러개의 브로커에 분산시켜 저장한다. 이는 확장성 측면에서도 아주 중요한 부분인데, 여러개의 프로듀서와 컨슈머가 동시에 여러 대의 브로커로부터 메세지를 읽고/쓰게 만들 수 있기 때문이다. 토픽에 새 이벤트를 발행하면 실제로 토픽의 특정 파티션에 추가된다. 같은 키를 가진 이벤트는 같은 파티션에 쓰여지고, 카프카는 어떤 컨슈머든 특정 토픽-파티션에 **쓰여진 순서와 동일하게** 이벤트를 읽을 수 있음을 보장한다.

또한 장애 허용, 고가용성을 위해 모든 토픽은 복제(replicated)된다. 시스템이 잘못된다든지, 특정 브로커를 유지보수 하는 상황을 대비하기 위해서이다. 일반적인 세팅값은 3이고, 이는 언제나 세 개의 복제본이 존재한다는 뜻이다. 
